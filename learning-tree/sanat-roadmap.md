# Sanat

> Computer Science > Design and Architecture > System Design > 1 Area of Expertise

## Computer Science 

- [ ] Learn C and Go
- [ ] Data Structures
  - [ ] Array
  - [ ] Linked List
  - [ ] Queue
  - [ ] Hash Table
  - [ ] Tree (binary, binary search, full binary, complete binary, balanced, unbalanced, )
  - [ ] Graph (directed, undirected, adjacency matrix, spanning tree, adjacency List
  - [ ] Heap
- [ ] Asymptotic Notation
  - [ ] Big O Notation
  - [ ] Big Theta Notaion
  - [ ] Big Omega Notation
  - [ ] Common Runtimes (constant, logarithmic, linear, polynomial, exponential, factorial)
- [ ] Common Algorithms
  - [ ] Sorting (bubble, selection, insertion, heap, quick, merge)
  - [ ] Searching (binary, linear)
  - [ ] Recursion (tail, non-tail)
  - [ ] Tree (pre-order traversal, in-order traversal, post order traversal, breadth first search, depth first search)
  - [ ] Graph (breadth first search, depth first search, bellman-ford, djisktras, A* algorithm)
  - [ ] Greedy (djisktras, huffman coding, kruksals, ford-fulkerson, prims)
  - [ ] Back tracking (finding hamiltonian paths, solving n queen, maze solving, the knights tour, rabin karp)
  - [ ] Caching (LRU chche, LFU cache, MFU cache)
- [ ] String Search & Manipulations
  - [ ] Search pattern in text
  - [ ] Suffix Arrays
  - [ ] Substring search (brute force, knuth-morris, boyer-moore, rabin-karp)
- [ ] Bitewise Operators
- [ ] Floating Point Numbers
- [ ] Endianes
  - [ ] Big Endian
  - [ ] Little Endian
- [ ] Character Encodings
  - [ ] Unicode
  - [ ] ASCII
- [ ] Common UML Diagrams
  - [ ] Class Diagrams
  - [ ] Usecase Diagrams
  - [ ] Activity Diagrams
  - [ ] Statemachine Diagrams
  - [ ] Sequence Diagrams
- [ ] Design Patterns 
  - [ ] GoF design patterns
  - [ ] Architectual patterns
  - [ ] Dependency injection
  - [ ] Null object pattern
  - [ ] Type object pattern 
- [ ] Basic Math
  - [ ] Probability
  - [ ] Combinatorics
- [ ] Complexity Classes
  - [ ] P
  - [ ] NP
  - [ ] Co-NP
  - [ ] NP-Hard
  - [ ] Np Complete (traveling salesman, knapscak, longest path)
  - [ ] P = NP
- [ ] Tries
- [ ] Balanced Search Trees
  - [ ] AVL Trees
  - [ ] Red / Black Trees
  - [ ] 2-3 Search Trees
  - [ ] 2-3-4 Trees
  - [ ] K-ary / M-ary Tree
  - [ ] B-Tree
- [ ] System Design
  - [ ] Horizontal vs Vertical Scaling
  - [ ] Load Balancing
  - [ ] Clustering
  - [ ] Caching
  - [ ] CDN
  - [ ] Proxy
  - [ ] CAP Theorem
  - [ ] Queues
  - [ ] Architectual Styles
  - [ ] REST
  - [ ] GraphQL
  - [ ] gRPC
  - [ ] Cloud Design Patterns
  - [ ] Long Polling
  - [ ] Short Polling
  - [ ] Web Sockets
  - [ ] SSE
- [ ] Databases 
  - [ ] SQL and NoSQL databases
  - [ ] Normalization / Deonormalization
  - [ ] Entity-relationship model
  - [ ] DDL
  - [ ] DML
  - [ ] DQL
  - [ ] DCL
  - [ ] Locking 
  - [ ] Transactions
  - [ ] AICD model
  - [ ] BASE model
  - [ ] CAP Theorem
  - [ ] PACELC
  - [ ] Indexes
  - [ ] Views
  - [ ] Transactions
  - [ ] Stored Procedures
  - [ ] Database Federation
  - [ ] Replication
  - [ ] Sharding
- [ ] Networking
  - [ ] OSI model
  - [ ] TCP/IP model
  - [ ] DNS
  - [ ] HTTP
  - [ ] HTTPS/TLS
  - [ ] Sockets
- [ ] Security
  - [ ] Public key cryptography
  - [ ] hashing, encryption, encoding
  - [ ] hashing algorithms
  - [ ] owasp top 10
- [ ] How Computers Work
  - [ ] How CPU executes programs?
  - [ ] How computers calculate
  - [ ] Registers and RAM
  - [ ] Instructions and Programs
  - [ ] CPU Cache
- [ ] Processes and Threads
  - [ ] Process Forking
  - [ ] Memory Management
  - [ ] Lock/mutex/semaphore
  - [ ] concurrency in multiple cores
  - [ ] scheduling algorithms
  - [ ] cpu interrutps
  - [ ] processes vs threads
- [ ] K - D Trees
- [ ] Skip Lists

---

## Software Design and Architecture

- [ ] Clean Code Principles
- [ ] Programming Paradigms
  - [ ] structured programming
  - [ ] functional programming
  - [ ] object oriented programming
- [ ] Object Oriented Programming
  - [ ] primary principles (inheritance, polymorphism, abstraction, encapsulation)
  - [ ] paradigm features (abstract classes, concrete classes, scope/visiblity, interfaces)
  - [ ] model-driven design (domain models, anemic models, layered architecturs, domain language, class invariants)
- [ ] Design Principles
  - [ ] composition over inheritance
  - [ ] encapsulate what varies
  - [ ] program against abstractions
  - [ ] hollywood principle
  - [ ] SOLID
  - [ ] DRY
  - [ ] YAGNI
- [ ] Design Patterns
  - [ ] GoF design patterns
  - [ ] PoSA patterns
- [ ] Architectual Principles
  - [ ] compontent principles
  - [ ] policy vs detail
  - [ ] coupling and cohesion
  - [ ] boundaries
- [ ] Architectual Styles
  - [ ] messaging (event-driven, publish-subscribe)
  - [ ] distrubuted (client-server, peer-to-peer)
  - [ ] structural (component-based, monlithic, layered)
- [ ] Architectual Patterns
  - [ ] SOA
  - [ ] CQRS
  - [ ] Domain driven design
  - [ ] Model-view-controller
  - [ ] microservies
  - [ ] blackboard pattern
  - [ ] microkernel
  - [ ] serverless architecture
  - [ ] message queues/streams
  - [ ] event sourcing
- [ ] Enterprise Patterns
  - [ ] DTOs
  - [ ] Identity Maps
  - [ ] use cases
  - [ ] repositeries
  - [ ] mappers
  - [ ] transaction script
  - [ ] commands/queries
  - [ ] value objects
  - [ ] domain models
  - [ ] entities
  - [ ] ORMs

---

## System Design

- [ ] Intro
  - [ ] What is system design
  - [ ] How to approach system design
- [ ] Performance vs Scalability
- [ ] Latency vs Throughput
- [ ] Availablity vs Consistency (CAP theorem)
  - [ ] AP - Availability + Partition Tolerance
  - [ ] CP - Consistency  + Partition Tolerence
- [ ] Consistency Patterns
  - [ ] Weak consistency
  - [ ] Eventual consistency
  - [ ] Strong consistency
- [ ] Availability Patterns
  - [ ] Availability in numbers
  - [ ] Fail Over (active-passive, active-active)
  - [ ] Replication (master-slave, master-master)
- [ ] Background Jobs
  - [ ] Event Driven
  - [ ] Schedule Driven
  - [ ] Returning - results
- [ ] Domain Name systems
- [ ] Content Delivery Networks
  - [ ] Push CDN
  - [ ] Pull CDN
- [ ] Load Balancers 
  - [ ] LB vs Rverse Proxy
  - [ ] Load Balancing Algorithms
  - [ ] Layer 7 Load Balancing
  - [ ] Layer-4 Load Balancing
  - [ ] Horizontal Scaling
- [ ] Application Layer
  - [ ] Microservices
  - [ ] Service Discovery
- [ ] Databases
  - [ ] SQL vs NoSQL
  - [ ] RDBMS (replication, sharding, federation, denormalization, sql tuning)
  - [ ] NoSQL (keyvalue, document, wide column, graph db)
- [ ] Caching
  - [ ] Strategies (refresh ahead, write-behind, write-thorugh, cache aside)
- [ ] Asynchronism
  - [ ] Back Pressure
  - [ ] Task Queues
  - [ ] Message Queues
- [ ] Idompotent Operations
- [ ] Comminucation
  - [ ] HTTP, TCP, UDP, RPC, REST, gRPC, GraphQL
- [ ] Performance Antipatterns
  - [ ] Busy Database
  - [ ] Busy Frontend
  - [ ] Chatty I/O
  - [ ] Extaneous Fetching
  - [ ] Improper Instantation
  - [ ] Monolithic Persistence
  - [ ] No Caching
  - [ ] Noisy Neighbor
  - [ ] Retry Storm
  - [ ] Synchronous I/O
- [ ] Monitoring
  - [ ] Health Monitoring
  - [ ] availablity monitoring
  - [ ] performance monitoring
  - [ ] security monitoring
  - [ ] usage monitoring
  - [ ] insturmentation
  - [ ] visualizataion and alerts
- [ ] Cloud design patterns (dont master have an overview)
  - [ ] Messaging 
  - [ ] Data Management
  - [ ] Design and Implementation
  - [ ] Reailability:  Availability
  - [ ] Reailability:  High Availaiblity
  - [ ] Reailability:  Resillency
  - [ ] Reailability:  Security
 

---

- Select one area in a field that you want to master such as robotics, finance, rocket ...etc. or carry on on networking and internet. it can be art as well.
